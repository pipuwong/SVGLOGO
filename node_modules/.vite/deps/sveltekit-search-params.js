import {
  derived,
  readable,
  writable
} from "./chunk-KTAX6ERY.js";
import {
  get_store_value
} from "./chunk-72CUDUMH.js";
import "./chunk-XSCOKBUT.js";
import "./chunk-4337NVKS.js";

// node_modules/.pnpm/sveltekit-search-params@2.1.2_@sveltejs+kit@2.5.7_svelte@4.2.15_vite@5.2.10/node_modules/sveltekit-search-params/package/sveltekit-search-params.js
import { browser, building } from "$app/environment";
import { goto } from "$app/navigation";
import { page as page_store } from "$app/stores";

// node_modules/.pnpm/sveltekit-search-params@2.1.2_@sveltejs+kit@2.5.7_svelte@4.2.15_vite@5.2.10/node_modules/sveltekit-search-params/package/lz-string/index.js
var f = String.fromCharCode;
var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
var baseReverseDic = {};
function getBaseValue(o, e) {
  if (!baseReverseDic[o]) {
    baseReverseDic[o] = {};
    for (let r = 0; r < o.length; r++)
      baseReverseDic[o][o.charAt(r)] = r;
  }
  return baseReverseDic[o][e];
}
function compressToEncodedURIComponent(o) {
  return null == o ? "" : _compress(o, 6, function(o2) {
    return keyStrUriSafe.charAt(o2);
  });
}
function decompressFromEncodedURIComponent(o) {
  return null == o ? "" : "" == o ? null : _decompress((o = o.replace(/ /g, "+")).length, 32, function(e) {
    return getBaseValue(keyStrUriSafe, o.charAt(e));
  });
}
function _compress(o, e, r) {
  if (null == o)
    return "";
  let i, t, s = {}, n = {}, $ = "", _ = "", p = "", a = 2, l = 3, c = 2, u = [], h = 0, d = 0, v;
  for (v = 0; v < o.length; v += 1)
    if ($ = o.charAt(v), Object.prototype.hasOwnProperty.call(s, $) || (s[$] = l++, n[$] = true), _ = p + $, Object.prototype.hasOwnProperty.call(s, _))
      p = _;
    else {
      if (Object.prototype.hasOwnProperty.call(n, p)) {
        if (256 > p.charCodeAt(0)) {
          for (i = 0; i < c; i++)
            h <<= 1, d == e - 1 ? (d = 0, u.push(r(h)), h = 0) : d++;
          for (i = 0, t = p.charCodeAt(0); i < 8; i++)
            h = h << 1 | 1 & t, d == e - 1 ? (d = 0, u.push(r(h)), h = 0) : d++, t >>= 1;
        } else {
          for (i = 0, t = 1; i < c; i++)
            h = h << 1 | t, d == e - 1 ? (d = 0, u.push(r(h)), h = 0) : d++, t = 0;
          for (i = 0, t = p.charCodeAt(0); i < 16; i++)
            h = h << 1 | 1 & t, d == e - 1 ? (d = 0, u.push(r(h)), h = 0) : d++, t >>= 1;
        }
        0 == --a && (a = Math.pow(2, c), c++), delete n[p];
      } else
        for (i = 0, t = s[p]; i < c; i++)
          h = h << 1 | 1 & t, d == e - 1 ? (d = 0, u.push(r(h)), h = 0) : d++, t >>= 1;
      0 == --a && (a = Math.pow(2, c), c++), s[_] = l++, p = String($);
    }
  if ("" !== p) {
    if (Object.prototype.hasOwnProperty.call(n, p)) {
      if (256 > p.charCodeAt(0)) {
        for (i = 0; i < c; i++)
          h <<= 1, d == e - 1 ? (d = 0, u.push(r(h)), h = 0) : d++;
        for (i = 0, t = p.charCodeAt(0); i < 8; i++)
          h = h << 1 | 1 & t, d == e - 1 ? (d = 0, u.push(r(h)), h = 0) : d++, t >>= 1;
      } else {
        for (i = 0, t = 1; i < c; i++)
          h = h << 1 | t, d == e - 1 ? (d = 0, u.push(r(h)), h = 0) : d++, t = 0;
        for (i = 0, t = p.charCodeAt(0); i < 16; i++)
          h = h << 1 | 1 & t, d == e - 1 ? (d = 0, u.push(r(h)), h = 0) : d++, t >>= 1;
      }
      0 == --a && (a = Math.pow(2, c), c++), delete n[p];
    } else
      for (i = 0, t = s[p]; i < c; i++)
        h = h << 1 | 1 & t, d == e - 1 ? (d = 0, u.push(r(h)), h = 0) : d++, t >>= 1;
    0 == --a && (a = Math.pow(2, c), c++);
  }
  for (i = 0, t = 2; i < c; i++)
    h = h << 1 | 1 & t, d == e - 1 ? (d = 0, u.push(r(h)), h = 0) : d++, t >>= 1;
  for (; ; ) {
    if (h <<= 1, d == e - 1) {
      u.push(r(h));
      break;
    }
    d++;
  }
  return u.join("");
}
function _decompress(o, e, r) {
  let i = [], t, s = 4, n = 4, $ = 3, _ = "", p = [], a, l, c, u, h, d, v, m = { val: r(0), position: e, index: 1 };
  for (a = 0; a < 3; a += 1)
    i[a] = a;
  for (c = 0, h = 4, d = 1; d != h; )
    u = m.val & m.position, m.position >>= 1, 0 == m.position && (m.position = e, m.val = r(m.index++)), c |= (u > 0 ? 1 : 0) * d, d <<= 1;
  switch (t = c) {
    case 0:
      for (c = 0, h = 256, d = 1; d != h; )
        u = m.val & m.position, m.position >>= 1, 0 == m.position && (m.position = e, m.val = r(m.index++)), c |= (u > 0 ? 1 : 0) * d, d <<= 1;
      v = f(c);
      break;
    case 1:
      for (c = 0, h = 65536, d = 1; d != h; )
        u = m.val & m.position, m.position >>= 1, 0 == m.position && (m.position = e, m.val = r(m.index++)), c |= (u > 0 ? 1 : 0) * d, d <<= 1;
      v = f(c);
      break;
    case 2:
      return "";
  }
  for (i[3] = v, l = v, p.push(v); ; ) {
    if (m.index > o)
      return "";
    for (c = 0, h = Math.pow(2, $), d = 1; d != h; )
      u = m.val & m.position, m.position >>= 1, 0 == m.position && (m.position = e, m.val = r(m.index++)), c |= (u > 0 ? 1 : 0) * d, d <<= 1;
    switch (v = c) {
      case 0:
        for (c = 0, h = 256, d = 1; d != h; )
          u = m.val & m.position, m.position >>= 1, 0 == m.position && (m.position = e, m.val = r(m.index++)), c |= (u > 0 ? 1 : 0) * d, d <<= 1;
        i[n++] = f(c), v = n - 1, s--;
        break;
      case 1:
        for (c = 0, h = 65536, d = 1; d != h; )
          u = m.val & m.position, m.position >>= 1, 0 == m.position && (m.position = e, m.val = r(m.index++)), c |= (u > 0 ? 1 : 0) * d, d <<= 1;
        i[n++] = f(c), v = n - 1, s--;
        break;
      case 2:
        return p.join("");
    }
    if (0 == s && (s = Math.pow(2, $), $++), i[v])
      _ = i[v];
    else {
      if (v !== n)
        return null;
      _ = l + l.charAt(0);
    }
    p.push(_), i[n++] = l + _.charAt(0), s--, l = _, 0 == s && (s = Math.pow(2, $), $++);
  }
}

// node_modules/.pnpm/sveltekit-search-params@2.1.2_@sveltejs+kit@2.5.7_svelte@4.2.15_vite@5.2.10/node_modules/sveltekit-search-params/package/sveltekit-search-params.js
var page;
if (building) {
  page = readable({
    url: new URL("https://github.com/paoloricciuti/sveltekit-search-params")
  });
} else {
  page = page_store;
}
var GOTO_OPTIONS = {
  keepFocus: true,
  noScroll: true,
  replaceState: true
};
var GOTO_OPTIONS_PUSH = {
  keepFocus: true,
  noScroll: true,
  replaceState: false
};
function mixSearchAndOptions(searchParams, overrides, options) {
  var _a;
  const uniqueKeys = Array.from(new Set(Array.from(((_a = searchParams == null ? void 0 : searchParams.keys) == null ? void 0 : _a.call(searchParams)) || []).concat(Object.keys(options ?? {}))));
  let anyDefaultedParam = false;
  return [
    Object.fromEntries(uniqueKeys.map((key) => {
      if (overrides[key] != void 0) {
        return [key, overrides[key]];
      }
      let fnToCall = (value2) => value2;
      const optionsKey = options == null ? void 0 : options[key];
      if (typeof optionsKey !== "boolean" && typeof (optionsKey == null ? void 0 : optionsKey.decode) === "function") {
        fnToCall = optionsKey.decode;
      }
      const value = searchParams == null ? void 0 : searchParams.get(key);
      let actualValue;
      if (value == void 0 && (optionsKey == null ? void 0 : optionsKey.defaultValue) != void 0) {
        actualValue = optionsKey.defaultValue;
        anyDefaultedParam = true;
      } else {
        actualValue = fnToCall(value);
      }
      return [key, actualValue];
    })),
    anyDefaultedParam
  ];
}
function isComplexEqual(current, next, equalityFn = (current2, next2) => JSON.stringify(current2) === JSON.stringify(next2)) {
  return typeof current === "object" && typeof next === "object" && equalityFn(current, next);
}
var ssp = {
  object: (defaultValue) => ({
    encode: (value) => JSON.stringify(value),
    decode: (value) => {
      if (value === null)
        return null;
      try {
        return JSON.parse(value);
      } catch (e) {
        return null;
      }
    },
    defaultValue
  }),
  array: (defaultValue) => ({
    encode: (value) => JSON.stringify(value),
    decode: (value) => {
      if (value === null)
        return null;
      try {
        return JSON.parse(value);
      } catch (e) {
        return null;
      }
    },
    defaultValue
  }),
  number: (defaultValue) => ({
    encode: (value) => value.toString(),
    decode: (value) => value ? parseFloat(value) : null,
    defaultValue
  }),
  boolean: (defaultValue) => ({
    encode: (value) => value + "",
    decode: (value) => value !== null && value !== "false",
    defaultValue
  }),
  string: (defaultValue) => ({
    encode: (value) => value ?? "",
    decode: (value) => value,
    defaultValue
  }),
  lz: (defaultValue) => ({
    encode: (value) => compressToEncodedURIComponent(JSON.stringify(value)),
    decode: (value) => {
      if (!value)
        return null;
      try {
        return JSON.parse(decompressFromEncodedURIComponent(value) ?? "");
      } catch (e) {
        return null;
      }
    },
    defaultValue
  })
};
var batchedUpdates = /* @__PURE__ */ new Set();
var batchTimeout;
var debouncedTimeouts = /* @__PURE__ */ new Map();
function queryParameters(options, { debounceHistory = 0, pushHistory = true, sort = true, showDefaults = true, equalityFn } = {}) {
  const overrides = writable({});
  let currentValue;
  let firstTime = true;
  function _set(value, changeImmediately) {
    if (!browser)
      return;
    firstTime = false;
    const hash = window.location.hash;
    const query = new URLSearchParams(window.location.search);
    const toBatch = (query2) => {
      for (const field of Object.keys(value)) {
        if (value[field] == void 0) {
          query2.delete(field);
          continue;
        }
        let fnToCall = (value2) => value2.toString();
        const optionsKey = options == null ? void 0 : options[field];
        if (typeof optionsKey !== "boolean" && typeof (optionsKey == null ? void 0 : optionsKey.encode) === "function") {
          fnToCall = optionsKey.encode;
        }
        const newValue = fnToCall(value[field]);
        if (newValue == void 0) {
          query2.delete(field);
        } else {
          query2.set(field, newValue);
        }
      }
    };
    batchedUpdates.add(toBatch);
    clearTimeout(batchTimeout);
    batchTimeout = setTimeout(async () => {
      batchedUpdates.forEach((batched) => {
        batched(query);
      });
      clearTimeout(debouncedTimeouts.get("queryParameters"));
      if (browser) {
        overrides.set(value);
        async function navigate() {
          if (sort) {
            query.sort();
          }
          await goto(`?${query}${hash}`, pushHistory ? GOTO_OPTIONS_PUSH : GOTO_OPTIONS);
          overrides.set({});
        }
        if (changeImmediately || debounceHistory === 0) {
          navigate();
        } else {
          debouncedTimeouts.set("queryParameters", setTimeout(navigate, debounceHistory));
        }
      }
      batchedUpdates.clear();
    });
  }
  const { subscribe } = derived([page, overrides], ([$page, $overrides], set) => {
    var _a;
    const [valueToSet, anyDefaultedParam] = mixSearchAndOptions((_a = $page == null ? void 0 : $page.url) == null ? void 0 : _a.searchParams, $overrides, options);
    if (anyDefaultedParam && showDefaults) {
      _set(valueToSet, firstTime);
    }
    if (isComplexEqual(currentValue, valueToSet, equalityFn)) {
      return;
    }
    currentValue = structuredClone(valueToSet);
    return set(valueToSet);
  });
  return {
    set(newValue) {
      _set(newValue);
    },
    subscribe,
    update: (updater) => {
      const currentValue2 = get_store_value({ subscribe });
      const newValue = updater(currentValue2);
      _set(newValue);
    }
  };
}
var DEFAULT_ENCODER_DECODER = {
  encode: (value) => value.toString(),
  decode: (value) => value ? value.toString() : null
};
function queryParam(name, { encode = DEFAULT_ENCODER_DECODER.encode, decode = DEFAULT_ENCODER_DECODER.decode, defaultValue } = DEFAULT_ENCODER_DECODER, { debounceHistory = 0, pushHistory = true, sort = true, showDefaults = true, equalityFn } = {}) {
  const override = writable(null);
  let firstTime = true;
  let currentValue;
  function _set(value, changeImmediately) {
    if (!browser)
      return;
    firstTime = false;
    const hash = window.location.hash;
    const toBatch = (query2) => {
      if (value == void 0) {
        query2.delete(name);
      } else {
        const newValue = encode(value);
        if (newValue == void 0) {
          query2.delete(name);
        } else {
          query2.set(name, newValue);
        }
      }
    };
    batchedUpdates.add(toBatch);
    clearTimeout(batchTimeout);
    const query = new URLSearchParams(window.location.search);
    batchTimeout = setTimeout(async () => {
      batchedUpdates.forEach((batched) => {
        batched(query);
      });
      clearTimeout(debouncedTimeouts.get(name));
      if (browser) {
        override.set(value);
        async function navigate() {
          if (sort) {
            query.sort();
          }
          await goto(`?${query}${hash}`, pushHistory ? GOTO_OPTIONS_PUSH : GOTO_OPTIONS);
          override.set(null);
        }
        if (changeImmediately || debounceHistory === 0) {
          navigate();
        } else {
          debouncedTimeouts.set(name, setTimeout(navigate, debounceHistory));
        }
      }
      batchedUpdates.clear();
    });
  }
  const { subscribe } = derived([page, override], ([$page, $override], set) => {
    var _a, _b, _c;
    if ($override != void 0) {
      if (isComplexEqual(currentValue, $override, equalityFn)) {
        return;
      }
      currentValue = structuredClone($override);
      return set($override);
    }
    const actualParam = (_c = (_b = (_a = $page == null ? void 0 : $page.url) == null ? void 0 : _a.searchParams) == null ? void 0 : _b.get) == null ? void 0 : _c.call(_b, name);
    if (actualParam == void 0 && defaultValue != void 0) {
      if (showDefaults) {
        _set(defaultValue, firstTime);
      }
      if (isComplexEqual(currentValue, defaultValue, equalityFn)) {
        return;
      }
      currentValue = structuredClone(defaultValue);
      return set(defaultValue);
    }
    const retval = decode(actualParam);
    if (isComplexEqual(currentValue, retval, equalityFn)) {
      return;
    }
    currentValue = structuredClone(retval);
    return set(retval);
  });
  return {
    set(newValue) {
      _set(newValue);
    },
    subscribe,
    update: (updater) => {
      const newValue = updater(currentValue);
      _set(newValue);
    }
  };
}
export {
  queryParam,
  queryParameters,
  ssp
};
//# sourceMappingURL=sveltekit-search-params.js.map
