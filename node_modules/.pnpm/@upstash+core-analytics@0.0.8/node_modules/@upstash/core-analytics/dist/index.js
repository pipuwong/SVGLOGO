"use strict";var g=Object.defineProperty;var k=Object.getOwnPropertyDescriptor;var _=Object.getOwnPropertyNames;var w=Object.prototype.hasOwnProperty;var y=(l,e)=>{for(var t in e)g(l,t,{get:e[t],enumerable:!0})},A=(l,e,t,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of _(e))!w.call(l,r)&&r!==t&&g(l,r,{get:()=>e[r],enumerable:!(n=k(e,r))||n.enumerable});return l};var v=l=>A(g({},"__esModule",{value:!0}),l);var x={};y(x,{Analytics:()=>p});module.exports=v(x);var b=`
local key = KEYS[1]
local field = ARGV[1]

local data = redis.call("ZRANGE", key, 0, -1, "WITHSCORES")
local count = {}

for i = 1, #data, 2 do
  local json_str = data[i]
  local score = tonumber(data[i + 1])
  local obj = cjson.decode(json_str)

  local fieldValue = obj[field]

  if count[fieldValue] == nil then
    count[fieldValue] = score
  else
    count[fieldValue] = count[fieldValue] + score
  end
end

local result = {}
for k, v in pairs(count) do
  table.insert(result, {k, v})
end

return result
`,f=`
local prefix = KEYS[1]
local first_timestamp = tonumber(ARGV[1])
local increment = tonumber(ARGV[2])
local num_timestamps = tonumber(ARGV[3])
local num_elements = tonumber(ARGV[4])

local keys = {}
for i = 1, num_timestamps do
  local timestamp = first_timestamp - (i - 1) * increment
  table.insert(keys, prefix .. ":" .. timestamp)
end

-- get the union of the groups
local zunion_params = {"ZUNION", num_timestamps, unpack(keys)}
table.insert(zunion_params, "WITHSCORES")
local result = redis.call(unpack(zunion_params))

-- select num_elements many items
local true_group = {}
local false_group = {}
local true_count = 0
local false_count = 0
local i = #result - 1

-- iterate over the results
while (true_count + false_count) < (num_elements * 2) and 1 <= i do
  local score = tonumber(result[i + 1])
  if score > 0 then
    local element = result[i]
    if string.find(element, "success\\":true") and true_count < num_elements then
      table.insert(true_group, {score, element})
      true_count = true_count + 1
    elseif string.find(element, "success\\":false") and false_count < num_elements then
      table.insert(false_group, {score, element})
      false_count = false_count + 1
    end
  end
  i = i - 2
end

return {true_group, false_group}
`,h=`
local prefix = KEYS[1]
local first_timestamp = tonumber(ARGV[1])
local increment = tonumber(ARGV[2])
local num_timestamps = tonumber(ARGV[3])

local keys = {}
for i = 1, num_timestamps do
  local timestamp = first_timestamp - (i - 1) * increment
  table.insert(keys, prefix .. ":" .. timestamp)
end

-- get the union of the groups
local zunion_params = {"ZUNION", num_timestamps, unpack(keys)}
table.insert(zunion_params, "WITHSCORES")
local result = redis.call(unpack(zunion_params))

return result
`;var p=class{redis;prefix;bucketSize;retention;constructor(e){this.redis=e.redis,this.prefix=e.prefix??"@upstash/analytics",this.bucketSize=this.parseWindow(e.window),this.retention=e.retention?this.parseWindow(e.retention):void 0}validateTableName(e){if(!/^[a-zA-Z0-9_-]+$/.test(e))throw new Error(`Invalid table name: ${e}. Table names can only contain letters, numbers, dashes and underscores.`)}parseWindow(e){if(typeof e=="number"){if(e<=0)throw new Error(`Invalid window: ${e}`);return e}let t=/^(\d+)([smhd])$/;if(!t.test(e))throw new Error(`Invalid window: ${e}`);let[,n,r]=e.match(t),i=parseInt(n);switch(r){case"s":return i*1e3;case"m":return i*1e3*60;case"h":return i*1e3*60*60;case"d":return i*1e3*60*60*24;default:throw new Error(`Invalid window unit: ${r}`)}}getBucket(e){let t=e??Date.now();return Math.floor(t/this.bucketSize)*this.bucketSize}async ingest(e,...t){this.validateTableName(e),await Promise.all(t.map(async n=>{let r=this.getBucket(n.time),i=[this.prefix,e,r].join(":");await this.redis.zincrby(i,1,JSON.stringify({...n,time:void 0}))}))}formatBucketAggregate(e,t,n){let r={};return e.forEach(([i,s])=>{t=="success"&&(i=i=="1"?"true":"false"),r[t]=r[t]||{},r[t][i]=s}),{time:n,...r}}async aggregateBucket(e,t,n){this.validateTableName(e);let r=this.getBucket(n),i=[this.prefix,e,r].join(":"),s=await this.redis.eval(b,[i],[t]);return this.formatBucketAggregate(s,t,r)}async aggregateBuckets(e,t,n,r){this.validateTableName(e);let i=this.getBucket(r),s=[];for(let o=0;o<n;o+=1)s.push(this.aggregateBucket(e,t,i)),i=i-this.bucketSize;return Promise.all(s)}async aggregateBucketsWithPipeline(e,t,n,r,i){this.validateTableName(e),i=i??48;let s=this.getBucket(r),o=[],a=this.redis.pipeline(),u=[];for(let c=1;c<=n;c+=1){let d=[this.prefix,e,s].join(":");a.eval(b,[d],[t]),o.push(s),s=s-this.bucketSize,(c%i==0||c==n)&&(u.push(a.exec()),a=this.redis.pipeline())}return(await Promise.all(u)).flat().map((c,d)=>this.formatBucketAggregate(c,t,o[d]))}async getAllowedBlocked(e,t,n){this.validateTableName(e);let r=[this.prefix,e].join(":"),i=this.getBucket(n),s=await this.redis.eval(h,[r],[i,this.bucketSize,t]),o={};for(let a=0;a<s.length;a+=2){let u=s[a],m=u.identifier,c=+s[a+1];o[m]||(o[m]={success:0,blocked:0}),o[m][u.success?"success":"blocked"]=c}return o}async getMostAllowedBlocked(e,t,n,r){this.validateTableName(e);let i=[this.prefix,e].join(":"),s=this.getBucket(r),[o,a]=await this.redis.eval(f,[i],[s,this.bucketSize,t,n]);return{allowed:this.toDicts(o),blocked:this.toDicts(a)}}toDicts(e){let t=[];for(let n=0;n<e.length;n+=1){let r=+e[n][0],i=e[n][1];t.push({identifier:i.identifier,count:r})}return t}};0&&(module.exports={Analytics});
