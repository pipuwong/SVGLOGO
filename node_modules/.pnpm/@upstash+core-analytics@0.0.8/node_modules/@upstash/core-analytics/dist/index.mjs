var d=`
local key = KEYS[1]
local field = ARGV[1]

local data = redis.call("ZRANGE", key, 0, -1, "WITHSCORES")
local count = {}

for i = 1, #data, 2 do
  local json_str = data[i]
  local score = tonumber(data[i + 1])
  local obj = cjson.decode(json_str)

  local fieldValue = obj[field]

  if count[fieldValue] == nil then
    count[fieldValue] = score
  else
    count[fieldValue] = count[fieldValue] + score
  end
end

local result = {}
for k, v in pairs(count) do
  table.insert(result, {k, v})
end

return result
`,g=`
local prefix = KEYS[1]
local first_timestamp = tonumber(ARGV[1])
local increment = tonumber(ARGV[2])
local num_timestamps = tonumber(ARGV[3])
local num_elements = tonumber(ARGV[4])

local keys = {}
for i = 1, num_timestamps do
  local timestamp = first_timestamp - (i - 1) * increment
  table.insert(keys, prefix .. ":" .. timestamp)
end

-- get the union of the groups
local zunion_params = {"ZUNION", num_timestamps, unpack(keys)}
table.insert(zunion_params, "WITHSCORES")
local result = redis.call(unpack(zunion_params))

-- select num_elements many items
local true_group = {}
local false_group = {}
local true_count = 0
local false_count = 0
local i = #result - 1

-- iterate over the results
while (true_count + false_count) < (num_elements * 2) and 1 <= i do
  local score = tonumber(result[i + 1])
  if score > 0 then
    local element = result[i]
    if string.find(element, "success\\":true") and true_count < num_elements then
      table.insert(true_group, {score, element})
      true_count = true_count + 1
    elseif string.find(element, "success\\":false") and false_count < num_elements then
      table.insert(false_group, {score, element})
      false_count = false_count + 1
    end
  end
  i = i - 2
end

return {true_group, false_group}
`,b=`
local prefix = KEYS[1]
local first_timestamp = tonumber(ARGV[1])
local increment = tonumber(ARGV[2])
local num_timestamps = tonumber(ARGV[3])

local keys = {}
for i = 1, num_timestamps do
  local timestamp = first_timestamp - (i - 1) * increment
  table.insert(keys, prefix .. ":" .. timestamp)
end

-- get the union of the groups
local zunion_params = {"ZUNION", num_timestamps, unpack(keys)}
table.insert(zunion_params, "WITHSCORES")
local result = redis.call(unpack(zunion_params))

return result
`;var p=class{redis;prefix;bucketSize;retention;constructor(e){this.redis=e.redis,this.prefix=e.prefix??"@upstash/analytics",this.bucketSize=this.parseWindow(e.window),this.retention=e.retention?this.parseWindow(e.retention):void 0}validateTableName(e){if(!/^[a-zA-Z0-9_-]+$/.test(e))throw new Error(`Invalid table name: ${e}. Table names can only contain letters, numbers, dashes and underscores.`)}parseWindow(e){if(typeof e=="number"){if(e<=0)throw new Error(`Invalid window: ${e}`);return e}let t=/^(\d+)([smhd])$/;if(!t.test(e))throw new Error(`Invalid window: ${e}`);let[,i,n]=e.match(t),r=parseInt(i);switch(n){case"s":return r*1e3;case"m":return r*1e3*60;case"h":return r*1e3*60*60;case"d":return r*1e3*60*60*24;default:throw new Error(`Invalid window unit: ${n}`)}}getBucket(e){let t=e??Date.now();return Math.floor(t/this.bucketSize)*this.bucketSize}async ingest(e,...t){this.validateTableName(e),await Promise.all(t.map(async i=>{let n=this.getBucket(i.time),r=[this.prefix,e,n].join(":");await this.redis.zincrby(r,1,JSON.stringify({...i,time:void 0}))}))}formatBucketAggregate(e,t,i){let n={};return e.forEach(([r,s])=>{t=="success"&&(r=r=="1"?"true":"false"),n[t]=n[t]||{},n[t][r]=s}),{time:i,...n}}async aggregateBucket(e,t,i){this.validateTableName(e);let n=this.getBucket(i),r=[this.prefix,e,n].join(":"),s=await this.redis.eval(d,[r],[t]);return this.formatBucketAggregate(s,t,n)}async aggregateBuckets(e,t,i,n){this.validateTableName(e);let r=this.getBucket(n),s=[];for(let o=0;o<i;o+=1)s.push(this.aggregateBucket(e,t,r)),r=r-this.bucketSize;return Promise.all(s)}async aggregateBucketsWithPipeline(e,t,i,n,r){this.validateTableName(e),r=r??48;let s=this.getBucket(n),o=[],a=this.redis.pipeline(),c=[];for(let l=1;l<=i;l+=1){let m=[this.prefix,e,s].join(":");a.eval(d,[m],[t]),o.push(s),s=s-this.bucketSize,(l%r==0||l==i)&&(c.push(a.exec()),a=this.redis.pipeline())}return(await Promise.all(c)).flat().map((l,m)=>this.formatBucketAggregate(l,t,o[m]))}async getAllowedBlocked(e,t,i){this.validateTableName(e);let n=[this.prefix,e].join(":"),r=this.getBucket(i),s=await this.redis.eval(b,[n],[r,this.bucketSize,t]),o={};for(let a=0;a<s.length;a+=2){let c=s[a],u=c.identifier,l=+s[a+1];o[u]||(o[u]={success:0,blocked:0}),o[u][c.success?"success":"blocked"]=l}return o}async getMostAllowedBlocked(e,t,i,n){this.validateTableName(e);let r=[this.prefix,e].join(":"),s=this.getBucket(n),[o,a]=await this.redis.eval(g,[r],[s,this.bucketSize,t,i]);return{allowed:this.toDicts(o),blocked:this.toDicts(a)}}toDicts(e){let t=[];for(let i=0;i<e.length;i+=1){let n=+e[i][0],r=e[i][1];t.push({identifier:r.identifier,count:n})}return t}};export{p as Analytics};
